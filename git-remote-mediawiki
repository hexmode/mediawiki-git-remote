#!/usr/bin/perl -w # -*- cperl; cperl-indent-level: 4; tab-width: 4; indent-tabs-mode: t -*-

# Copyright (C) 2017  Mark A. Hershberger

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Gateway between Git and MediaWiki.
# Documentation & bugtracker: https://github.com/hexmode/mediawiki-git-remote
# Based on the work found at https://github.com/Git-Mediawiki/Git-Mediawiki/

# Copyright (C) 2011
#     Jérémie Nikaes <jeremie.nikaes@ensimag.imag.fr>
#     Arnaud Lacurie <arnaud.lacurie@ensimag.imag.fr>
#     Claire Fousse <claire.fousse@ensimag.imag.fr>
#     David Amouyal <david.amouyal@ensimag.imag.fr>
#     Matthieu Moy <matthieu.moy@grenoble-inp.fr>
# License: GPL v2 or later


use strict;
use Data::Dumper;
use Date::Parse;
use MediaWiki::API;
use Git;
use File::Basename;
use lib dirname(__FILE__);
use Git::Mediawiki qw(clean_filename smudge_filename connect_maybe
                      EMPTY HTTP_CODE_OK);
use Encode qw( encode decode );
use warnings;

# By default, use UTF-8 to communicate with Git and the user
binmode STDERR, ':encoding(UTF8)';
binmode STDOUT, ':encoding(UTF8)';

use URI::Escape;

# It's not always possible to delete pages (may require some
# privileges). Deleted pages are replaced with this content.
use constant DELETED_CONTENT => "[[Category:Deleted]]\n";

# It's not possible to create empty pages. New empty files in Git are
# sent with this content instead.
use constant EMPTY_CONTENT => "<!-- empty page -->\n";

# used to reflect file creation or deletion in diff.
use constant NULL_SHA1 => '0000000000000000000000000000000000000000';

# Used on Git's side to reflect empty edit messages on the wiki
use constant EMPTY_MESSAGE => '*Empty MediaWiki Message*';

# Number of pages taken into account at once in submodule get_page_list
use constant SLICE_SIZE => 50;

# Number of linked mediafile to get at once in get_linked_mediafiles
# The query is split in small batches because of the MW API limit of
# the number of links to be returned (500 links max).
use constant BATCH_SIZE => 10;

if (@ARGV != 2) {
  exit_error_usage();
}

my $VERBOSE = 1;
my $remotename = $ARGV[0];
my $url = $ARGV[1];

# Accept both space-separated and multiple keys in config file.
# Spaces should be written as _ anyway because we'll use chomp.
my @tracked_pages = get_git_remote_list( "page" );

# Just like @tracked_pages, but for MediaWiki categories.
my @tracked_categories = get_git_remote_list( "category" );

# Import media files on pull
my $_mediaFlag = get_git_remote_value("media");
my $import_media = ( lc( $_mediaFlag ) eq 'import'
                       or lc( $_mediaFlag ) eq 'both' );

# Export media files on push
my $export_media = ( lc( $_mediaFlag ) eq 'export'
                       or lc( $_mediaFlag ) eq 'both' );

my $all_namespaces = {};
map {
  my ($k, $v) = split(":", $_, 2);
  $all_namespaces->{$k} = $v;
} get_git_remote_list("namespaceCache");
if (scalar keys %$all_namespaces == 0) {
  get_namespaces();
}

my $use_namespace = get_git_remote_value("mwUnderNS");

my $wiki_login = get_git_remote_value("mwLogin");
# Note: mwPassword is discouraged. Use the credential system instead.
my $wiki_passwd = get_git_remote_value("mwPassword");
my $wiki_domain = get_git_remote_value("mwDomain");

# Import only last revisions (both for clone and fetch)
my $shallow_import = get_git_remote_bool("shallow");

# Fetch (clone and pull) by revisions instead of by pages. This behavior
# is more efficient when we have a wiki with lots of pages and we fetch
# the revisions quite often so that they concern only few pages.
# Possible values:
# - by_rev: perform one query per new revision on the remote wiki
# - by_page: query each tracked page for new revision
my $fetch_strategy = get_git_remote_value("fetchStrategy")
  || get_git_value('mediawiki.fetchStrategy') || 'by_page';

# The extension to provide local copies of (non-file) pages
my $page_ext = get_git_value('mediawiki.pageExtension') || '.mw';

# Remember the timestamp corresponding to a revision id.
my %basetimestamps;

# Dumb push: don't update notes and mediawiki ref to reflect the last push.
#
# Configurable with mediawiki.dumbPush, or per-remote with
# remote.<remotename>.dumbPush.
#
# This means the user will have to re-import the just-pushed
# revisions. On the other hand, this means that the Git revisions
# corresponding to MediaWiki revisions are all imported from the wiki,
# regardless of whether they were initially created in Git or from the
# web interface, hence all users will get the same history (i.e. if
# the push from Git to MediaWiki loses some information, everybody
# will get the history with information lost). If the import is
# deterministic, this means everybody gets the same sha1 for each
# MediaWiki revision.
my $dumb_push = get_git_remote_bool("dumbPush")
  || get_git_bool('mediawiki.dumbPush');

my $wiki_name = $url;
$wiki_name =~ s{[^/]*://}{};
# If URL is like http://user:password@example.com/, we clearly don't
# want the password in $wiki_name. While we're there, also remove user
# and '@' sign, to avoid author like MWUser@HTTPUser@host.com
$wiki_name =~ s/^.*@//;

# Commands parser
while (<STDIN>) {
  chomp;
  warn "Got command $_\n"
    if $VERBOSE & 2;
  if (!parse_command($_)) {
    last;
  }

  # flush STDOUT, to make sure the previous
  # command is fully processed.
  BEGIN { $| = 1 }
}

########################## Functions ##############################

# syntantic sugar to make it clear what we're doing
sub tell_git {
  warn "Telling git: @_\n"
    if $VERBOSE & 16;
  print @_;
}

## error handling
sub exit_error_usage {
  die <<EOB
ERROR: git-remote-mediawiki module was not called with a correct number of parameters.

You may obtain this error because you attempted to run the git-remote-mediawiki
module directly.

This module can be used the following way:
	git clone mediawiki://<address of a mediawiki>
Then, use git commit, push and pull as with every normal git repository.
EOB
}

sub parse_command {
  my ($line) = @_;
  my @cmd = split(/ /, $line);
  if (!defined $cmd[0]) {
    return 0;
  }
  if ($cmd[0] eq 'capabilities') {
    die("Too many arguments for capabilities\n")
      if (defined($cmd[1]));
    mw_capabilities();
  } elsif ($cmd[0] eq 'list') {
    die("Too many arguments for list\n") if (defined($cmd[2]));
    mw_list($cmd[1]);
  } elsif ($cmd[0] eq 'import') {
    die("Invalid argument for import\n")
      if ($cmd[1] eq EMPTY);
    die("Too many arguments for import\n")
      if (defined($cmd[2]));
    mw_import($cmd[1]);
  } elsif ($cmd[0] eq 'option') {
    die("Invalid arguments for option\n")
      if ($cmd[1] eq EMPTY || $cmd[2] eq EMPTY);
    die("Too many arguments for option\n")
      if (defined($cmd[3]));
    mw_option($cmd[1],$cmd[2]);
  } elsif ($cmd[0] eq 'push') {
    mw_push($cmd[1]);
  } else {
    warn "Unknown command. Aborting...\n";
    return 0;
  }
  return 1;
}

# MediaWiki API instance, created lazily.
my $mediawiki;

sub fatal_mw_error {
  my $action = shift;
  warn "fatal: could not $action.\n";
  warn "fatal: '$url' does not appear to be a mediawiki\n";
  my $msg = "fatal: make sure '$url/api.php' is a valid endpoint";
  if ($url =~ /^https/) {
    $msg .= "fatal: and the SSL certificate is correct";
  }
  warn "$msg.\n";
  warn "fatal: (error " .
    $mediawiki->{error}->{code} . ': ' .
    $mediawiki->{error}->{details} . ")\n";
  exit 1;
}

## Functions for listing pages on the remote wiki
sub get_tracked_pages {
  my $pages = shift;
  get_page_list(\@tracked_pages, $pages);
  return;
}

sub get_page_list {
  my $page_list = shift;
  my $pages = shift;
  my @some_pages = @{$page_list};
  while (@some_pages) {
    my $last_page = SLICE_SIZE;
    if ($#some_pages < $last_page) {
      $last_page = $#some_pages;
    }
    my @slice = @some_pages[0..$last_page];
    get_first_pages(\@slice, $pages);
    @some_pages = @some_pages[(SLICE_SIZE + 1)..$#some_pages];
  }
  return;
}

sub get_tracked_categories {
  my $pages = shift;
  foreach my $category (@tracked_categories) {
    if (index($category, ':') < 0) {
      # Mediawiki requires the Category
      # prefix, but let's not force the user
      # to specify it.
      $category = "Category:${category}";
    }
    my $mw_pages = $mediawiki->list( {
      action => 'query',
      list => 'categorymembers',
      cmtitle => $category,
      cmlimit => 'max' } )
      || die $mediawiki->{error}->{code} . ': '
      . $mediawiki->{error}->{details} . "\n";
    foreach my $page (@{$mw_pages}) {
      $pages->{$page->{title}} = $page;
    }
  }
  return;
}

sub get_all_pages {
  my $pages = shift;
  # No user-provided list, get the list of pages from the API.
  my $batch = BATCH_SIZE;
  my $theseNS = $use_namespace
    ? [ $use_namespace ]
    : [keys %$all_namespaces];
  foreach my $ns ( @$theseNS ) {
    warn "Processing $ns\n" if $VERBOSE & 1;
    my $mw_pages = get_pages_in_namespace($ns);
    if (!defined($mw_pages)) {
      fatal_mw_error("get the list of wiki pages");
    }
    while (my $page = $mw_pages->()) {
      $pages->{$page->{title}} = $page;
    }
  }
  return;
}

# queries the wiki for a set of pages. Meant to be used within a loop
# querying the wiki for slices of page list.
sub get_first_pages {
  my $some_pages = shift;
  my @some_pages = @{$some_pages};

  my $pages = shift;

  # pattern 'page1|page2|...' required by the API
  my $titles = join('|', @some_pages);

  my $mw_pages = $mediawiki->api({
    action => 'query',
    titles => $titles,
  });
  if (!defined($mw_pages)) {
    fatal_mw_error("query the list of wiki pages");
  }
  while (my ($id, $page) = each(%{$mw_pages->{query}->{pages}})) {
    if ($id < 0) {
      warn "Warning: page $page->{title} not found on wiki\n"
        if $VERBOSE & 1;
    } else {
      $pages->{$page->{title}} = $page;
    }
  }
  return;
}

# Get the list of pages to be fetched according to configuration.
sub get_pages {
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  my $user_defined;
  my %pages;
  if (@tracked_pages) {
    warn "Listing tracked pages on remote wiki...\n"
      if $VERBOSE & 1;
    $user_defined = 1;
    # The user provided a list of pages titles, but we
    # still need to query the API to get the page IDs.
    get_tracked_pages(\%pages);
  }
  if (@tracked_categories) {
    warn "Listing tracked categories on remote wiki...\n"
      if $VERBOSE & 1;
    $user_defined = 1;
    get_tracked_categories(\%pages);
  }
  if ($use_namespace) {
    my $iter = get_pages_in_namespace( $use_namespace );
    $user_defined = 1;
    while (my $page = $iter->()) {
      $pages{$page->{title}} = $page;
    }
  }
  if (!$user_defined) {
    warn "Listing all pages on remote wiki...\n" if $VERBOSE & 1;
    get_all_pages(\%pages);
  }
  if ($import_media) {
    warn "Getting media files for selected pages...\n"
      if $VERBOSE & 1;
    if ($user_defined) {
      get_linked_mediafiles(\%pages);
    } else {
      get_all_mediafiles(\%pages);
    }
  }
  # Don't think this is necessary since it will only pull pages twice
  # if ($all_namespaces && !$use_namespace) {
  #   get_other_namespaces( \%pages );
  # }
  if ($VERBOSE & 1) {
    my $found = scalar keys %pages;
    if ($found == 1) {
      warn "1 page found.\n";
    }
    if ($found > 1) {
      warn "$found pages found.\n";
    }
    if (!$found) {
      warn "No pages found.\n";
    }
  }
  return %pages;
}

# usage: $out = run_git("command args");

#        don't interpret output as UTF-8:
#        $out = run_git("command args", "raw");
sub run_git {
  my $args = shift;
  my $encoding = (shift || 'encoding(UTF-8)');
  warn "executing 'git $args' with encoding: $encoding\n" if $VERBOSE & 4;
  open(my $git, "-|:${encoding}", "git ${args}")
    or die "Unable to fork: $!\n";
  my $res = do {
    local $/ = undef;
    <$git>
  };
  close($git);
  warn "git returned: $res\n" if $VERBOSE & 4;
  return $res;
}

sub get_git_remote_bool {
  my $name = shift;
  return get_git_bool("remote.${remotename}.$name");
}

sub get_git_bool {
  my $name = shift;
  my $ret = run_git("config --get --bool $name") || "";
  chomp ( $ret );
  return ( $ret eq 'true' );
}

sub get_git_remote_list {
  my $name = shift;
  my @ret = split(/[\n]/, run_git(
    "config --get-all remote.${remotename}.$name") );

  return @ret;
}

sub get_git_remote_value {
  my $name = shift;
  return get_git_value( "remote.${remotename}.$name" );
}

sub get_git_value {
  my $name = shift;
  my $ret = run_git("config --get $name") || "";
  chomp ( $ret );
  return $ret;
}

sub mw_add_all_ns {
  my( $name, $id ) = @_;
  $name =~ s/ /_/g;
  $all_namespaces->{$name} = $id;
  run_git(qq(config --add remote.${remotename}.) .
            qq(namespaceCache "$name:$id"));
}

sub get_namespaces {
  if (scalar keys %$all_namespaces != 0) {
    return $all_namespaces;
  }
  $all_namespaces = {};
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);
  my $resp = $mediawiki->api({
    action => 'query',
    meta => 'siteinfo',
    siprop => 'namespaces'
  });
  if (!defined $resp) {
    fatal_mw_error("get namespaces");
  }
  my %ns = %{$resp->{query}->{namespaces}};
  foreach my $ns (keys %ns) {
    if ($ns < 0 ) {
      delete $ns{$ns};
      next;
    }
    my $name = $ns{$ns}{'*'};
    my $canon = $ns{$ns}{'canonical'}
      ? $ns{$ns}{'canonical'} : $name;
    warn "Got $name/$canon namespace.\n" if $VERBOSE & 2;
    $ns{$name} = $ns{$ns};
    mw_add_all_ns( $name, $ns{$ns}{id} );
    if ($name ne $canon) {
      $ns{$canon} = $ns{$ns};
      mw_add_all_ns( $canon, $ns{$ns}{id} );
    }
    delete $ns{$ns};
  }

  return \%ns;
}

sub get_page_chunk {
  my ($ns, $from) = @_;


  if ($ns && $from) {
    # Since $ns might not match (e.g. "Project" != "Wikipedia")
    $from =~ s/^[^:]*:(.*)/$1/;
  }
  if (!defined $from) {
    $from = "";
  }
  warn "starting on $from" if $VERBOSE & 4 and $from;
  my $ret = $mediawiki->list({
    action => 'query',
    apfrom => $from || "",
    list => 'allpages',
    apnamespace => $all_namespaces->{$ns},
    aplimit => 'max',
  });
  if (ref $ret eq "ARRAY") {
    return @{$ret}
  }
  return ();
}

sub get_pages_in_namespace {
  my $ns = shift;
  my ($current_page, $done, @pages);
  @pages = get_page_chunk($ns);

  return sub {
    # code to calculate $next_page or $done;
    if (scalar @pages == 0) {
      if (exists $current_page->{title}) {
        @pages =
          get_page_chunk($ns, $current_page->{title});
      }
      if (scalar @pages > 0 && $pages[0]->{title} eq
            $current_page->{title}) {
        shift @pages;
      }
      if (scalar @pages == 0) {
        return;
      }
    }
    $current_page = shift @pages;
    warn "Got from the wiki: $current_page->{title}...\n"
      if $VERBOSE & 8;
    return $current_page;
  };
}

sub get_other_namespaces {
  my $pages = shift;
  my %nameSpace = %$all_namespaces;
  foreach my $ns (keys %nameSpace) {
    if ($ns eq 'File') {
      next;
    }
    if (exists($nameSpace{$ns})) {
      my $pageList = get_pages_in_namespace($ns);
      if ($pages) {
        while (my $page = $pageList->()) {
          $pages->{$page->{title}} = $page;
        }
      }
    }
  }
  return;
}

sub get_all_mediafiles {
  my $pages = shift;
  # Attach list of all pages for media files from the API,
  # they are in a different namespace, only one namespace
  # can be queried at the same moment
  my $mw_pages = get_pages_in_namespace('File');
  if (!defined($mw_pages)) {
    fatal_mw_error("get a list of pages for media files");
  }
  while (my $page = $mw_pages->()) {
    $pages->{$page->{title}} = $page;
  }
  return;
}

sub get_linked_mediafiles {
  my $pages = shift;
  my @titles = map { $_->{title} } values(%{$pages});

  my $batch = BATCH_SIZE;
  while (@titles) {
    if ($#titles < $batch) {
      $batch = $#titles;
    }
    my @slice = @titles[0..$batch];

    # pattern 'page1|page2|...' required by the API
    my $mw_titles = join('|', @slice);

    # Media files could be included or linked from
    # a page, get all related
    my $query = {
      action => 'query',
      prop => 'links|images',
      titles => $mw_titles,
      plnamespace => get_namespace_id('File'),
      pllimit => 'max'
    };
    my $result = $mediawiki->api($query);

    while (my ($id, $page) = each(%{$result->{query}->{pages}})) {
      my @media_titles;
      if (defined($page->{links})) {
        my @link_titles
          = map { $_->{title} } @{$page->{links}};
        push(@media_titles, @link_titles);
      }
      if (defined($page->{images})) {
        my @image_titles
          = map { $_->{title} } @{$page->{images}};
        push(@media_titles, @image_titles);
      }
      if (@media_titles) {
        get_page_list(\@media_titles, $pages);
      }
    }

    @titles = @titles[($batch+1)..$#titles];
  }
  return;
}

sub get_mediafile_for_page_revision {
  # Name of the file on Wiki, with the prefix.
  my $filename = shift;
  my $timestamp = shift;
  my %mediafile;

  # Search if on a media file with given timestamp exists on
  # MediaWiki. In that case download the file.
  my $query = {
    action => 'query',
    prop => 'imageinfo',
    titles => "File:${filename}",
    iistart => $timestamp,
    iiend => $timestamp,
    iiprop => 'timestamp|archivename|url',
    iilimit => 1
  };
  my $result = $mediawiki->api($query);

  my ($fileid, $file) = each( %{$result->{query}->{pages}} );
  # If not defined it means there is no revision of the file for
  # given timestamp.
  if (defined($file->{imageinfo})) {
    $mediafile{title} = $filename;

    my $fileinfo = pop(@{$file->{imageinfo}});
    $mediafile{timestamp} = $fileinfo->{timestamp};
    # Mediawiki::API's download function doesn't support https URLs
    # and can't download old versions of files.
    warn "\tDownloading file $mediafile{title}, " .
      "version $mediafile{timestamp}\n"
      if $VERBOSE & 1;
    $mediafile{content} = download_mw_mediafile($fileinfo->{url});
  }
  return %mediafile;
}

sub download_mw_mediafile {
  my $download_url = shift;

  my $response = $mediawiki->{ua}->get($download_url);
  if ( $response->{success} ) {
    return $response->{content};
  } else {
    warn "Error downloading mediafile from :\n";
    warn "URL: ${download_url}\n";
    warn 'Server response: ' . $response->{status} . q{ } .
      $response->{reason} . "\n";
  }
}

sub get_notes {
  my $remotename = shift;
  my $what = shift;

  my $note = run_git(qq(notes --ref=${remotename}/mediawiki show ) .
                       qq(refs/mediawiki/) .
                       qq(${remotename}/master ) .
                       qq(2>/dev/null));
  my @notes = split(/\n/, $note);
  my %noted;
  foreach (@notes) {
    my ($key, $value) = split(/: /, $_, 2);
    if ($what eq $key) {
      return $value;
    }
    $noted{$key} = $value;
  }
  if ($what) {
    return;
  }
  return \%noted;
}

sub get_last_local_revision {
  # Get note regarding last mediawiki revision
  my $lastrev_number =
    get_notes( $remotename, 'mediawiki_revision' );
  if (!$lastrev_number) {
    warn "No previous mediawiki revision found.\n";
    $lastrev_number = 0;
  } else {
    warn "Last local mediawiki revision found is $lastrev_number.\n"
      if $VERBOSE & 1;
  }
  return $lastrev_number;
}

# Get the last remote revision without taking in account which pages are
# tracked or not. This function makes a single request to the wiki thus
# avoid a loop onto all tracked pages. This is useful for the fetch-by-rev
# option.
sub get_last_global_remote_rev {
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  my $query = {
    action => 'query',
    list => 'recentchanges',
    prop => 'revisions',
    rclimit => '1',
    rcdir => 'older',
  };
  my $result = $mediawiki->api($query);
  warn "Last global remote rev: " .
    $result->{query}->{recentchanges}[0]->{revid} . "\n"
    if $VERBOSE & 1;
  return $result->{query}->{recentchanges}[0]->{revid};
}

# Get the last remote revision concerning the tracked pages and the tracked
# categories.
sub get_last_remote_revision {
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  my %pages_hash = get_pages();
  my @pages = values(%pages_hash);

  my $max_rev_num = 0;

  warn "Getting last revision id on tracked pages...\n"
    if $VERBOSE & 1;

  foreach my $page (@pages) {
    my $id = $page->{pageid};

    my $query = {
      action => 'query',
      prop => 'revisions',
      rvprop => 'ids|timestamp',
      pageids => $id,
    };

    my $result = $mediawiki->api($query);

    my $lastrev = pop(
      @{$result->{query}->{pages}->{$id}->{revisions}}
    );

    $basetimestamps{$lastrev->{revid}} = $lastrev->{timestamp};

    $max_rev_num = ($lastrev->{revid} > $max_rev_num
                      ? $lastrev->{revid}
                      : $max_rev_num);
  }

  warn "Last remote revision found is $max_rev_num.\n"
    if $VERBOSE & 1;
  return $max_rev_num;
}

# Clean content before sending it to MediaWiki
sub mediawiki_clean {
  my $string = shift;
  my $page_created = shift;
  # Mediawiki does not allow blank space at the end of a page and
  # ends with a single \n.  This function right trims a string and
  # adds a \n at the end to follow this rule
  $string =~ s/\s+$//;
  if ($string eq EMPTY && $page_created) {
    # Creating empty pages is forbidden.
    $string = EMPTY_CONTENT;
  }
  return $string."\n";
}

# Filter applied on MediaWiki data before adding them to Git
sub mediawiki_smudge {
  my $string = shift;
  if ($string eq EMPTY_CONTENT) {
    $string = EMPTY;
  }
  # This \n is important. This is due to mediawiki's way to handle
  # end of files.
  return "${string}\n";
}

sub literal_data {
  my ($content) = @_;
  tell_git 'data ', bytes::length($content), "\n", $content;
  return;
}

sub literal_data_raw {
  # Output possibly binary content.
  my ($content) = @_;
  # Avoid confusion between size in bytes and in characters
  utf8::downgrade($content);
  binmode STDOUT, ':raw';
  tell_git 'data ', bytes::length($content), "\n", $content;
  binmode STDOUT, ':encoding(UTF-8)';
  return;
}

sub mw_capabilities {
  # Revisions are imported to the private namespace
  # refs/mediawiki/$remotename/ by the helper and fetched into
  # refs/remotes/$remotename later by fetch.
  tell_git "refspec refs/heads/*:refs/mediawiki/${remotename}/*\n";
  tell_git "import\n";
  tell_git "list\n";
  tell_git "push\n";
  if ($dumb_push) {
    tell_git "no-private-update\n";
  }
  tell_git "\n";
  return;
}

sub mw_list {
  # MediaWiki do not have branches, we consider one branch arbitrarily
  # called master, and HEAD pointing to it.
  tell_git "? refs/heads/master\n";
  tell_git "\@refs/heads/master HEAD\n";
  tell_git "\n";
  return;
}

sub mw_option {
  warn "remote-helper command 'option $_[0]' not yet implemented\n";
  tell_git "unsupported\n";
  return;
}

sub fetch_mw_revisions_for_page {
  my $page = shift;
  my $id = shift;
  my $fetch_from = shift;
  my @page_revs = ();
  my $query = {
    action => 'query',
    prop => 'revisions',
    rvprop => 'ids',
    rvdir => 'newer',
    rvstartid => $fetch_from,
    rvlimit => 500,
    pageids => $id,

    # Let MediaWiki know that we support the latest API.
    continue => '',
  };

  my $revnum = 0;
  # Get 500 revisions at a time due to the mediawiki api limit
  while (1) {
    my $result = $mediawiki->api($query);

    # Parse each of those 500 revisions
    foreach (@{$result->{query}->{pages}->{$id}->{revisions}}) {
      my $page_rev_ids;
      $page_rev_ids->{pageid} = $page->{pageid};
      $page_rev_ids->{revid} = $_->{revid};
      push(@page_revs, $page_rev_ids);
      $revnum++;
    }

    if ($result->{'query-continue'}) { # For legacy APIs
      $query->{rvstartid} =
        $result->{'query-continue'}->{revisions}->{rvstartid};
    } elsif ($result->{continue}) { # For newer APIs
      $query->{rvstartid} = $result->{continue}->{rvcontinue};
      $query->{continue} = $result->{continue}->{continue};
    } else {
      last;
    }
  }
  if ($shallow_import && @page_revs) {
    warn "  Found 1 revision (shallow import).\n" if $VERBOSE & 4;
    @page_revs = sort {$b->{revid} <=> $a->{revid}} (@page_revs);
    return $page_revs[0];
  }
  warn "  Found ${revnum} revision(s).\n" if $VERBOSE & 4;
  return @page_revs;
}

sub fetch_mw_revisions {
  my $pages = shift;
  my $fetch_from = shift;

  my @revisions = ();
  my $n = 1;
  my $count = scalar @{$pages};
  foreach my $page (@$pages) {
    my $id = $page->{pageid};
    warn "page ${n}/$count: ", $page->{title}, "\n" if $VERBOSE & 4;
    $n++;
    my @page_revs =
      fetch_mw_revisions_for_page($page, $id, $fetch_from);
    @revisions = (@page_revs, @revisions);
  }

  return ($n, @revisions);
}

sub import_file_revision {
  my $commit = shift;
  my %commit = %{$commit};
  my $full_import = shift;
  my $n = shift;
  my $mediafile = shift;
  my %mediafile;
  if ($mediafile) {
    %mediafile = %{$mediafile};
  }

  my $title = $commit{title};
  my $comment = $commit{comment};
  my $content = $commit{content};
  my $author = $commit{author};
  my $date = $commit{date};

  tell_git "commit refs/mediawiki/${remotename}/master\n";
  tell_git "mark :${n}\n";
  tell_git "committer ${author} <${author}\@${wiki_name}> $date +0000\n";
  literal_data($comment);

  # If it's not a clone, we need to know where to start from
  if (!$full_import && $n == 1) {
    tell_git "from refs/mediawiki/${remotename}/master^0\n";
  }
  # FIXME replace this with a function call
  if ($title !~ m{\.(css|js)$}i) {
    $title = "$title$page_ext";
  }
  if ($content ne DELETED_CONTENT) {
    tell_git "M 644 inline $title\n";
    literal_data($content);
    if (%mediafile) {
      tell_git "M 644 inline $mediafile{title}\n";
      literal_data_raw($mediafile{content});
    }
    tell_git "\n\n";
  } else {
    tell_git "D $title\n";
  }

  # mediawiki revision number in the git note
  if ($full_import && $n == 1) {
    tell_git "reset refs/notes/${remotename}/mediawiki\n";
  }
  tell_git "commit refs/notes/${remotename}/mediawiki\n";
  tell_git "committer ${author} <${author}\@${wiki_name}> $date +0000\n";
  literal_data('Note added by git-mediawiki during import');
  if (!$full_import && $n == 1) {
    tell_git "from refs/notes/${remotename}/mediawiki^0\n";
  }
  tell_git "N inline :${n}\n";
  literal_data( "mediawiki_revision: $commit{mw_revision}\n".
                  "mediawiki_timestamp: $date" );
  tell_git "\n\n";
  return;
}

# parse a sequence of
# <cmd> <arg1>
# <cmd> <arg2>
# \n
# (like batch sequence of import and sequence of push statements)
sub get_more_refs {
  my $cmd = shift;
  my @refs;
  while (1) {
    chomp(my $line = <STDIN>);
    warn "Got another line: $line\n"
      if $VERBOSE & 2;
    if ($line =~ /^$cmd (.*)$/) {
      push(@refs, $1);
    } elsif ($line eq "") {
      return @refs;
    } else {
      die("Invalid command in this '$cmd' batch: $_\n");
    }
  }
  return;
}

sub uniq {
  my %seen;
  return grep { !$seen{$_}++ } @_;
}

sub mw_import {
  # multiple import commands can follow each other.
  my @refs = uniq(shift, get_more_refs('import'));
  warn "Got refs: " . join( "\n\t", @refs ) . "\n"
    if $VERBOSE && 2;
  foreach my $ref (@refs) {
    mw_import_ref($ref);
  }
  tell_git "done\n";
  return;
}

sub mw_import_ref {
  my $ref = shift;

  # This does not seem to be accurate any more:
  #     The remote helper will call "import HEAD" and
  #     "import refs/heads/master".
  #     Since HEAD is a symbolic ref to master (by convention,
  #     followed by the output of the command "list" that we gave),
  #     we don't need to do anything in this case.
  # We're getting "import refs/heads/master" twice and uniq handles it.
  if ($ref eq 'HEAD') {
    return;
  }

  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  warn "Searching revisions...\n" if $VERBOSE & 1;
  my $last_local = get_last_local_revision();
  my $fetch_from = $last_local + 1;
  my $last_remote_rev = get_last_global_remote_rev();

  if ( $fetch_from > $last_remote_rev ) {
    warn "Up to date!\n";
    return;
  }

  if ($fetch_from == 1) {
    warn "Fetching from beginning.\n" if $VERBOSE & 1;
  } else {
    warn "Fetching from here.\n" if $VERBOSE & 1;
  }

  my $n = 0;
  if ($fetch_strategy eq 'by_rev') {
    warn "Fetching & writing export data by revs...\n"
      if $VERBOSE & 1;
    $n = mw_import_ref_by_revs($fetch_from);
  } elsif ($fetch_strategy eq 'by_page') {
    warn "Fetching & writing export data by pages...\n"
      if $VERBOSE & 1;
    $n = mw_import_ref_by_pages($fetch_from);
  } else {
    warn<<EOB;
fatal: invalid fetch strategy "${fetch_strategy}".
Check your configuration variables remote.${remotename}.fetchStrategy
and mediawiki.fetchStrategy
EOB
    exit 1;
  }

  if ($fetch_from == 1 && $n == 0) {
    warn "You appear to have cloned an empty MediaWiki.\n";
    # Something has to be done remote-helper side. If nothing is
    # done, an error is thrown saying that HEAD is referring to
    # unknown object 0000000000000000000 and the clone fails.
  }
  return;
}

sub mw_import_ref_by_pages {

  my $fetch_from = shift;
  my %pages_hash = get_pages();
  my @pages = values(%pages_hash);

  my ($n, @revisions) = fetch_mw_revisions(\@pages, $fetch_from);

  @revisions = sort {$a->{revid} <=> $b->{revid}} @revisions;
  my @revision_ids = map { $_->{revid} } @revisions;

  return mw_import_revids($fetch_from, \@revision_ids, \%pages_hash);
}

sub mw_import_ref_by_revs {

  my $fetch_from = shift;
  my %pages_hash = get_pages();

  my $last_remote = get_last_global_remote_rev();
  my @revision_ids = $fetch_from..$last_remote;
  return mw_import_revids($fetch_from, \@revision_ids, \%pages_hash);
}

# Import revisions given in second argument (array of integers).
# Only pages appearing in the third argument (hash indexed by page titles)
# will be imported.
sub mw_import_revids {
  my $fetch_from = shift;
  my $revision_ids = shift;
  my $pages = shift;

  my $n = 0;
  my $n_actual = 0;
  # Placeholer in case $rev->timestamp is undefined
  my $last_timestamp = 0;

  foreach my $pagerevid (@{$revision_ids}) {
    # Count page even if we skip it, since we display
    # $n/$total and $total includes skipped pages.
    $n++;

    # fetch the content of the pages
    my $query = {
      action => 'query',
      prop => 'revisions',
      rvprop => 'content|timestamp|comment|user|ids',
      revids => $pagerevid,
    };

    my $result = $mediawiki->api($query);
    if (!$result) {
      die "Failed to retrieve modified page for revision " .
        $pagerevid . "\n";
    }

    if (defined($result->{query}->{badrevids}->{$pagerevid})) {
      # The revision id does not exist on the remote wiki.
      next;
    }

    if (!defined($result->{query}->{pages})) {
      die "Invalid revision ${pagerevid}.\n";
    }

    my @result_pages = values(%{$result->{query}->{pages}});
    my $result_page = $result_pages[0];
    my $rev = $result_pages[0]->{revisions}->[0];

    my $page_title = $result_page->{title};
    # FIXME
    # Differentiates classic pages and media files.
    my %mediafile;
    my ($namespace, $filename);
    # doh, doesn't work with main namespace
    if ($use_namespace && $page_title !~ /^$use_namespace:/) {
      warn "Skipping $namespace because it doesn't match '" .
        $use_namespace ."'\n"
        if $VERBOSE & 1;
      return;
    } else {
      ($namespace, $filename) =
        $page_title =~ /^([^:]*):(.*)$/;
    }

    if (defined($namespace)) {
      my $id = get_namespace_id($namespace);
      if (defined($id) and $id == get_namespace_id('File')) {
        %mediafile = get_mediafile_for_page_revision(
          $filename, $rev->{timestamp}
        );
      }
    }

    if (!exists($pages->{$page_title})) {
      warn "${n}/", scalar(@{$revision_ids}),
        ": Skipping revision #$rev->{revid} of $page_title\n";
      next;
    }

    $n_actual++;

    my %commit;
    $commit{author} = $rev->{user} || 'Anonymous';
    $commit{comment} = $rev->{comment} || EMPTY_MESSAGE;
    $commit{title} = smudge_filename($page_title, $use_namespace);
    $commit{mw_revision} = $rev->{revid};
    $commit{content} = mediawiki_smudge($rev->{'*'});
    if (!defined($rev->{timestamp})) {
      $last_timestamp++;
    } else {
      $last_timestamp = $rev->{timestamp};
    }
    $commit{date} = str2time($last_timestamp);

    # If this is a revision of the media page for new version
    # of a file do one common commit for both file and media page.
    # Else do commit only for that page.
    warn "${n}/", scalar(@{$revision_ids}),
      ": Revision #$rev->{revid} of $commit{title}\n";
    import_file_revision(
      \%commit, ($fetch_from == 1), $n_actual, \%mediafile
    );
  }

  return $n_actual;
}

sub error_non_fast_forward {
  my $advice = get_git_bool('advice.pushNonFastForward');
  if ($advice) {
    # Native git-push would show this after the summary.
    # We can't ask it to display it cleanly, so print it
    # ourselves before.
    warn<<EOB
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. 'git pull') before pushing again. See the
'Note about fast-forwards' section of 'git push --help' for details.
EOB
  }
  tell_git qq(error $_[0] "non-fast-forward"\n);
  return 0;
}

sub mw_upload_file {
  my $complete_file_name = shift;
  my $new_sha1 = shift;
  my $extension = shift;
  my $file_deleted = shift;
  my $summary = shift;
  my $newrevid;
  my $path = "File:${complete_file_name}";
  my %hashFiles = get_allowed_file_extensions();
  if (!exists($hashFiles{$extension})) {
    warn "${complete_file_name} is not a permitted file on this" .
      " wiki.\n";
    return $newrevid;
  }
  # Deleting and uploading a file requires a privileged user
  if ($file_deleted) {
    $mediawiki = connect_maybe($mediawiki, $remotename, $url);
    my $query = {
      action => 'delete',
      title => $path,
      reason => $summary
    };
    if (!$mediawiki->edit($query)) {
      warn "Failed to delete file on remote wiki\n";
      warn "Check your permissions on the remote site.\n";
      warn "Error code: " . $mediawiki->{error}->{code} . ':'
        . $mediawiki->{error}->{details};
      exit 1;
    }
  } else {
    # Don't let perl try to interpret file content as UTF-8 => use
    # "raw"
    my $content = run_git("cat-file blob ${new_sha1}", 'raw');
    if ($content ne EMPTY) {
      $mediawiki = connect_maybe($mediawiki, $remotename,
                                 $url);
      $mediawiki->{config}->{upload_url} =
        "${url}/index.php/Special:Upload";
      $mediawiki->edit({
        action => 'upload',
        filename => $complete_file_name,
        comment => $summary,
        file => [undef, $complete_file_name,
                 Content => $content],
        ignorewarnings => 1,
      }, {
        skip_encoding => 1
      } ) || die "Error uploading $complete_file_name: " .
      $mediawiki->{error}->{code} . ':' .
      $mediawiki->{error}->{details} . "\n";
      my $last_file_page =
        $mediawiki->get_page({title => $path});
      $newrevid = $last_file_page->{revid};
      warn "Pushed file: ${new_sha1} - " .
        $complete_file_name . ".\n";
    } else {
      warn "Empty file ${complete_file_name} not pushed.\n";
    }
  }
  return $newrevid;
}

sub mw_get_contenttype {
  my $filename = shift;

  if ($filename =~ /\.php$/) {
    return 'text/php';
  }
  if ($filename =~ /\.js$/) {
    return 'text/javascript';
  }
  if ($filename =~ /\.json$/) {
    return 'application/json';
  }
  if ($filename =~ /\.css$/) {
    return 'text/css';
  }

  return 'text/x-wiki';
}

sub mw_get_contentmodel {
  my $filename = shift;

  if ($filename =~ /\.php$/) {
    return 'php';
  }
  if ($filename =~ /\.js$/) {
    return 'javascript';
  }
  if ($filename =~ /\.json$/) {
    return 'json';
  }
  if ($filename =~ /\.css$/) {
    return 'css';
  }

  return 'wikitext';
}

sub mw_really_push_file {
  my ($complete_file_name, $new_sha1, $extension, $page_deleted, $summary,
      $oldrevid, $title, $page_created) = @_;
  my $newrevid;
  my $ns = get_namespace_id_for_page(
    ( $use_namespace ? "$use_namespace:" : "" )
      . $complete_file_name);
  if ($ns && $ns ne 'notANameSpace' &&
        $ns == get_namespace_id('File') && (!$export_media)) {
    warn "Ignoring media file related page: $complete_file_name.\n";
    return ($oldrevid, 'ok');
  }
  my $file_content;
  if ($page_deleted) {
    # Deleting a page usually requires
    # special privileges. A common
    # convention is to replace the page
    # with this content instead:
    $file_content = DELETED_CONTENT;
  } else {
    $file_content = run_git("cat-file blob ${new_sha1}", "raw");
  }

  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  my $thisns = $use_namespace ? ("$use_namespace:") : '';
  my $arg = {
    action => 'edit',
    summary => $summary,
    title => $thisns . $complete_file_name,
    basetimestamp => $basetimestamps{$oldrevid},
    contenttype => mw_get_contenttype( $complete_file_name ),
    contentmodel => mw_get_contentmodel( $complete_file_name ),
    text => mediawiki_clean($file_content, $page_created),
  };

  my $result = $mediawiki->edit( $arg, {
    # Helps with names with accentuated characters:
    skip_encoding => 1
  });
  if (!$result) {
    if ($mediawiki->{error}->{code} == 3) {
      # edit conflicts, considered as non-fast-forward
      warn 'Warning: Error ' .
        $mediawiki->{error}->{code} .
        ' from mediawiki: ' . $mediawiki->{error}->{details} .
        ".\n";
      return ($oldrevid, 'non-fast-forward');
    } else {
      # Other errors. Shouldn't happen => just die()
      die 'Fatal: Error ' .
        $mediawiki->{error}->{code} .
        ' from mediawiki: ' .
        $mediawiki->{error}->{details} . "\n";
    }
  }
  $newrevid = $result->{edit}->{newrevid};
  warn "Pushed file: ${new_sha1} - ${complete_file_name}\n";
  return $newrevid;
}

sub mw_is_text {
  my $ext = shift;

  if ($ext =~ /^(png|gif)$/) {
    return;
  }
  return 1;
}
sub mw_push_file {
  my $diff_info = shift;
  # $diff_info contains a string in this format:
  # 100644 100644 <sha1_of_blob_before_commit> <sha1_of_blob_now> <status>
  my @diff_info_split = split(/[ \t]/, $diff_info);

  my $complete_file_name = shift;
  # Commit message
  my $summary = shift;
  # MediaWiki revision number. Keep the previous one by default,
  # in case there's no edit to perform.
  my $oldrevid = shift;
  my $newrevid;

  if ($summary eq EMPTY_MESSAGE) {
    $summary = EMPTY;
  }

  my $new_sha1 = $diff_info_split[3];
  my $old_sha1 = $diff_info_split[2];
  my $page_created = ($old_sha1 eq NULL_SHA1);
  my $page_deleted = ($new_sha1 eq NULL_SHA1);
  $complete_file_name = clean_filename($complete_file_name);

  my ($title, $extension) = $complete_file_name =~ /^(.*)\.([^\.]*)$/;
  if (!defined($extension)) {
    $extension = EMPTY;
  }
  if (mw_is_text($extension)) {
    $newrevid = mw_really_push_file($complete_file_name, $new_sha1,
                                    $extension, $page_deleted, $summary,
                                    $oldrevid, $title, $page_created);
  } elsif ($export_media) {
    $newrevid = mw_upload_file($complete_file_name, $new_sha1,
                               $extension, $page_deleted,
                               $summary);
  } else {
    warn "Ignoring media file ${complete_file_name}\n";
  }
  $newrevid = ($newrevid or $oldrevid);
  return ($newrevid, 'ok');
}

sub mw_push {
  # multiple push statements can follow each other
  my @refsspecs = (shift, get_more_refs('push'));
  my $pushed;
  for my $refspec (@refsspecs) {
    my ($force, $local, $remote) = $refspec =~ /^(\+)?([^:]*):([^:]*)$/
      or die("Invalid refspec for push. " .
             "Expected <src>:<dst> or +<src>:<dst>\n");
    if ($force) {
      warn "Warning: forced push not allowed on MediaWiki.\n";
    }
    if ($local eq EMPTY) {
      warn "Cannot delete remote branch on a MediaWiki\n";
      tell_git "error ${remote} cannot delete\n";
      next;
    }
    if ($remote ne 'refs/heads/master') {
      warn "Only push to the branch 'master' is supported " .
        " on MediaWiki\n";
      tell_git "error ${remote} only master allowed\n";
      next;
    }
    if (mw_push_revision($local, $remote)) {
      $pushed = 1;
    }
  }

  # Notify Git that the push is done
  tell_git "\n";

  if ($pushed && $dumb_push) {
    warn<<EOB
Just pushed some revisions to MediaWiki.
The pushed revisions now have to be re-imported, and your current branch
needs to be updated with these re-imported commits. You can do this with
  git pull --rebase

EOB
  }
  return;
}

sub mw_push_revision {
  my $local = shift;
  # actually, this has to be "refs/heads/master" at this point.
  my $remote = shift;
  my $last_local_revid = get_last_local_revision();
  my $last_remote_revid = get_last_remote_revision();
  my $mw_revision = $last_remote_revid;

  # Get sha1 of commit pointed by local HEAD
  my $HEAD_sha1 = run_git("rev-parse ${local} 2>/dev/null");
  chomp($HEAD_sha1);
  # Get sha1 of commit pointed by remotes/$remotename/master
  my $remoteorigin_sha1 =
    run_git("rev-parse refs/remotes/${remotename}/master 2>/dev/null");
  chomp($remoteorigin_sha1);

  if ($last_local_revid > 0 &&
        $last_local_revid < $last_remote_revid) {
    return error_non_fast_forward($remote);
  }

  if ($HEAD_sha1 eq $remoteorigin_sha1) {
    # nothing to push
    return 0;
  }

  # Get every commit in between HEAD and refs/remotes/origin/master,
  # including HEAD and refs/remotes/origin/master
  my @commit_pairs = ();
  if ($last_local_revid > 0) {
    my $parsed_sha1 = $remoteorigin_sha1;
    # Find a path from last MediaWiki commit to pushed commit
    warn "Computing path from local to remote ...\n";
    my @local_ancestry =
      split(/\n/, run_git("rev-list --boundary --parents ${local} ^${parsed_sha1}"));
    my %local_ancestry;
    foreach my $line (@local_ancestry) {
      if (my ($child, $parents) = $line =~ /^-?([a-f0-9]+) ([a-f0-9 ]+)/) {
        foreach my $parent (split(/ /, $parents)) {
          $local_ancestry{$parent} = $child;
        }
      } elsif (!$line =~ /^([a-f0-9]+)/) {
        die "Unexpected output from git rev-list: ${line}\n";
      }
    }
    while ($parsed_sha1 ne $HEAD_sha1) {
      my $child = $local_ancestry{$parsed_sha1};
      if (!$child) {
        warn "Cannot find a path in history from remote commit to last commit\n";
        return error_non_fast_forward($remote);
      }
      push(@commit_pairs, [$parsed_sha1, $child]);
      $parsed_sha1 = $child;
    }
  } else {
    # No remote mediawiki revision. Export the whole
    # history (linearized with --first-parent)
    warn "Warning: no common ancestor, pushing complete history\n";
    my $history = run_git("rev-list --first-parent --children ${local}");
    my @history = split(/\n/, $history);
    @history = @history[1..$#history];
    foreach my $line (reverse @history) {
      my @commit_info_split = split(/[ \n]/, $line);
      push(@commit_pairs, \@commit_info_split);
    }
  }

  foreach my $commit_info_split (@commit_pairs) {
    my $sha1_child = @{$commit_info_split}[0];
    my $sha1_commit = @{$commit_info_split}[1];
    my $diff_infos = run_git("diff-tree -r --raw -z ${sha1_child} ${sha1_commit}");
    # TODO: we could detect rename, and encode them with a
    # #redirect on the wiki.
    # TODO: for now, it's just a
    # delete+add
    my @diff_info_list = split(/\0/, $diff_infos);
    # Keep the subject line of the commit message as mediawiki
    # comment for the revision
    my $commit_msg = run_git(qq(log --no-walk --format="%s" ) .
                               $sha1_commit);
    chomp($commit_msg);
    # Push every blob
    while (@diff_info_list) {
      my $status;
      # git diff-tree -z gives an output like
      # <metadata>\0<filename1>\0
      # <metadata>\0<filename2>\0
      # and we've split on \0.
      my $info = shift(@diff_info_list);
      my $file = shift(@diff_info_list);
      ($mw_revision, $status) =
        mw_push_file($info, $file, $commit_msg, $mw_revision);
      if ($status eq 'non-fast-forward') {
				# we may already have sent part of the
				# commit to MediaWiki, but it's too
				# late to cancel it. Stop the push in
				# the middle, but still give an
				# accurate error message.
        return error_non_fast_forward($remote);
      }
      if ($status ne 'ok') {
        die("Unknown error from mw_push_file()\n");
      }
    }
    if (!$dumb_push) {
      run_git(qq(notes --ref=${remotename}/mediawiki ) .
                "add -f -m \"mediawiki_revision: " .
                $mw_revision .qq(" ) .
                $sha1_commit);
    }
  }

  tell_git "ok ${remote}\n";
  return 1;
}

sub get_allowed_file_extensions {
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);

  my $query = {
    action => 'query',
    meta => 'siteinfo',
    siprop => 'fileextensions'
  };
  my $result = $mediawiki->api($query);
  my @file_extensions = map { $_->{ext}}
    @{$result->{query}->{fileextensions}};
  my %hashFile = map { $_ => 1 } @file_extensions;

  return %hashFile;
}

# Return MediaWiki id for a given namespace name.
# Ex.: "File", "Project".
sub get_namespace_id {
  $mediawiki = connect_maybe($mediawiki, $remotename, $url);
  my $name = shift;
  $name =~ s/ /_/g;

  if (!exists $all_namespaces->{$name}) {
    warn "Namespace '${name}' not found in cache, " .
      "refetching namespaces ...\n";
    # NS not found => get namespace id from MW and store it in
    # configuration file.
    get_namespaces();
  }

  if (!exists($all_namespaces->{$name})) {
    warn "No such namespace '${name}' on this wiki.\n";
  }

  return exists( $all_namespaces->{$name} )
    ? $all_namespaces->{$name} : "notANameSpace";
}

sub get_namespace_id_for_page {
  my $namespace = shift;
  if ($namespace =~ /^([^:]*):/) {
    return get_namespace_id($1);
  } else {
    return;
  }
}
